<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>The Harvest Manifesto</title>
        <meta name="description" content="The Harvest Manifesto">
        <meta name="viewport" content="width=device-width">

        <link rel="stylesheet" href="css/normalize.min.css">
        <link rel="stylesheet" href="css/main.css">
        <link href='http://fonts.googleapis.com/css?family=Fredericka+the+Great' rel='stylesheet' type='text/css'>

        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
            <script>window.html5 || document.write('<script src="js/vendor/html5shiv.js"><\/script>')</script>
        <![endif]-->
    </head>
    <body>

        <div id=content>
            <header>
                <small>The</small> <h1>Harvest Manifesto</h1>
            </header>

            <p class=headline>Harvest was designed to alleviate the opaqueness of complex data models and large data sets. Each come with their own set of challenges.</p>

            <ul class=toc>
                <li><a href=#complex>Complex Data Models</a>
                <li><a href=#large>Large Data Sets</a>
            </ul>

            <hr>


            <h2 id=complex>Complex Data Models</h2>
            
            <p>Complex is more attractive sounding, but even simple data models can benefit from a really good data access layer API.</p>

            <h3>Perceivably <em>flat</em> data access layer</h3>

            <p>It is simpler to choose/search from a list of items than to attempt to traverse a relational data model or document store. Many times you simply <em>don't know</em> what you're looking for or when you do, you don't (and shouldn't) know where to look.</p>

            <h3>Descriptive metadata (and domain specificity)</h3>

            <p>Merely having a data model and it's constraints is not enough. The first barrier for users is figuring out <em>what</em> about the data they can search for. Humanize the data model by adding some descriptive love.</p>

            <h3>Free-text data model search</h3>
            <p>An intuitive and powerful search depends on the first two points mentioned above. The (highly descriptive) metadata as well as the structural metadata can be indexed and searched against directly. A <em>match</em> in this case would be particular data point whether it is for query or display purposes.</p>

            <h3>Expand the search by including the data itself</h3>

            <p>To make the search more robust, discreate data can be indexed and associated with each data point as well. As an example, if I type <code>male</code>, the available query or view options may result in <code>gender</code>. This enables users to find what they are looking for by directly searching for the a known data value. One caveat to this is regarding permissions. If certain end are not allowed to view certain data, a match occuring from typing <code>male</code> would potentially mean there are <code>male</code> data values.</p>

            <h3>Humans aren't constrained, databases schemas are (and for good reason)</h3>

            <p>Databases have <em>data types</em> to allow for fast and effective search on data. For example, you cannot query the string <code>hello world</code> using a numerical operator (as least in a way that makes sense). For this reason, data are split up into multiple fields suting the needs of the data. For example when you view a cooking recipe, you would expect to read an ingredient such as <em>2 teaspoons of salt</em>. What would happen if you only knew the ingredient name i.e. <em>salt</em>? You wouldn't know <em>how much</em> of the ingredient you need. Likewise if you only saw <em>teaspoons</em> without <em>2</em>, you would not know the quantity of <em>salt</em> to add.</p>

            <p>The power of the database comes from storing and indexing discrete values which enables fast search and sorting capabilities. Humans however need to be able to view these discrete values in way that means something to them.</p>


            <hr>
                

            <h2 id=large>Large Data Sets</h2>

            <p>Large data sets should <em>only</em> benefit users in the sense that they have more data to explore.  Similar to the comment on complexity.. small data sets will work just fine here as well.</p>

            <h3>Usability must have an O(1) relationship to data size</h3>

            <p>The scale of the data must not tax it's usability. Interfaces must be able to scale with the data transparently and not burden the user with too many options at once.</p>

            <h3>Aggregate statistics</h3>

            <p>Most data should be looked at an aggregate level. If you choose the view <code>gender</code> data, the appropriate view is a series aggregate counts for <code>male</code>, <code>female</code> and <code>unknown</code>. This immediately gives the user a sense of the data. For example, if the are interesting in the <code>male</code> population, but the data set only has a few, they can make the decision to continue or not.</p>

            <p>These statistics can be thought of as another set of metadata. This time it's computed from the data itself.</p>
            
            <h3>Distributions graphs</h3>
            
            <p>This goes hand-in-hand with displaying aggregate statistics. This is particularly important for continuous data where simply listing a bunch of data value counts would be overwhelming. Again, the goal is for a user to <em>get a sense</em> of the data before having to query or view it.</p>

        </div>
        <script>
            var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
